---
layout:     post
title:      面试题
subtitle:   面试题
date:       2019-09-05
author:     clown
header-img: img/post-bg-ios9-web.jpg
catalog:         true
tags:
    - java
    - linux
    - python
---
# JAVA面试题
## 四种引用类型
1. 强引用
默认引用形式,比如
```
Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收
obj = null;  //手动置null
```
回收机制:只有被赋予null时才会被回收,内存不足时抛出OutOfMemoryError
2. 软引用
```
public class TestOOM {
    private static List<Object> list = new ArrayList<>();
    public static void main(String[] args) {
         testSoftReference();
    }
    private static void testSoftReference() {
        for (int i = 0; i < 10; i++) {
            byte[] buff = new byte[1024 * 1024];
            SoftReference<byte[]> sr = new SoftReference<>(buff);
            list.add(sr);
        }
        
        System.gc(); //主动通知垃圾回收
        
        for(int i=0; i < list.size(); i++){
            Object obj = ((SoftReference) list.get(i)).get();
            System.out.println(obj);
        }
        
    }
    
}
```
回收机制:内存足够时,不回收软引用类型;类型不足时,程序报错
3. 弱引用
```
 private static void testWeakReference() {
        for (int i = 0; i < 10; i++) {
            byte[] buff = new byte[1024 * 1024];
            WeakReference<byte[]> sr = new WeakReference<>(buff);
            list.add(sr);
        }
        
        System.gc(); //主动通知垃圾回收
        
        for(int i=0; i < list.size(); i++){
            Object obj = ((WeakReference) list.get(i)).get();
            System.out.println(obj);
        }
    }
```
回收机制: 只要系统开始内存回收就被回收掉
4. 虚引用
回收机制: 随时被回收
## 线程状态
| 状态 | 说明 |
| :---:        |     :---:      |
| New  | 初始状态,线程被构建,但是没有启动start()方法   |
| RUNNABLE     | 运行状态,就绪和运行两种状态被称为"运行中"       |
| BLOCKED | 阻塞状态 |
| WAITING | 等待状态,等待其他线程通知 |
| TIME_WAITING | 超时等待,等一段时间后返回 |
| TERMINATED | 终止状态,表示当前线程执行完毕 |
5. 使用数组实现栈
```
public class MyStack {
    private int[] storage;//存放栈中元素的数组
    private int capacity;//栈的容量
    private int count;//栈中元素数量
    private static final int GROW_FACTOR = 2;

    //TODO：不带初始容量的构造方法。默认容量为8
    public MyStack() {
        this.capacity = 8;
        this.storage=new int[8];
        this.count = 0;
    }

    //TODO：带初始容量的构造方法
    public MyStack(int initialCapacity) {
        if (initialCapacity < 1)
            throw new IllegalArgumentException("Capacity too small.");

        this.capacity = initialCapacity;
        this.storage = new int[initialCapacity];
        this.count = 0;
    }

    //TODO：入栈
    public void push(int value) {
        if (count == capacity) {
            ensureCapacity();
        }
        storage[count++] = value;
    }

    //TODO：确保容量大小
    private void ensureCapacity() {
        int newCapacity = capacity * GROW_FACTOR;
        storage = Arrays.copyOf(storage, newCapacity);
        capacity = newCapacity;
    }

    //TODO：返回栈顶元素并出栈
    private int pop() {
        count--;
        if (count == -1)
            throw new IllegalArgumentException("Stack is empty.");

        return storage[count];
    }

    //TODO：返回栈顶元素不出栈
    private int peek() {
        if (count == 0){
            throw new IllegalArgumentException("Stack is empty.");
        }else {
            return storage[count-1];
        }
    }

    //TODO：判断栈是否为空
    private boolean isEmpty() {
        return count == 0;
    }

    //TODO：返回栈中元素的个数
    private int size() {
        return count;
    }

}
```

